from fastapi import APIRouter, Query, Depends, Header, HTTPException
from fastapi.responses import JSONResponse
from routers.auth import verify_access_token
from db import db_manager as dm
from db.queries import VULNERABILITIES_RETRIEVAL_QUERIES as VR_QUERIES
from db.actions import VulnerabilityRetrievalActions as VR_ACTIONS
from utils import util
from utils.ratelimit import BUCKETS, TokenBucket

vulnerabilitiy_router = APIRouter()
vulnerabilities_db_manager = dm.DatabaseManager("vulnerabilities-db/cves.sqlite")
devices_db_manager = dm.DatabaseManager("vulnerabilities-db/affected_devices.sqlite")


@vulnerabilitiy_router.on_event("startup")
async def startup():
    await vulnerabilities_db_manager.connect()
    await devices_db_manager.connect()

@vulnerabilitiy_router.on_event("shutdown")
async def shutdown():
    await vulnerabilities_db_manager.disconnect()
    await devices_db_manager.disconnect()

def create_bucket_for_token(access_token = Header(...)):
    hashed_token = hash(access_token)
    if hashed_token not in BUCKETS:
        bucket = TokenBucket()
        BUCKETS[hashed_token] = bucket
    
    if BUCKETS[hashed_token].available_calls <= 0:
        raise HTTPException(status_code=429, detail="Rate limit exceed!")

    BUCKETS[hashed_token].decrement_calls()


async def list_vulnerabilities_by_page_token(page_token, limit):
    """Fetch vulnerabilities using pagination mechanism.

    Args:
        page_token (str, optional): Provide page token. Defaults to Query(default="").
        limit (int, optional): Limit number of vulnerabilities to fetch. Defaults to Query(default=100, ge=1, le=1000).

    Returns:
        dict: List of vulnerabilities and annotated information.
    """
    try:
        offset = 0
        prev_page_token = page_token
        next_page_token = page_token
        response = {"total": 0, "vulnerabilities": []}
        
        if page_token:
            offset = util.compute_page_offset_from_token(page_token)
        
        if isinstance(offset, str):
            return JSONResponse(status_code=400, content={"message": offset})
        
        data = await VR_ACTIONS.fetch_vulnerabilities(vulnerabilities_db_manager, values={"limit": limit, "offset": offset})
        response["vulnerabilities"] = data
        if data:
            prev_page_token = util.encode_value(min(data[0][0] - limit, 0))
            next_page_token = util.encode_value(data[-1][0] + 1)
        
        if offset > 0:
            response["prev_page_token"] = prev_page_token
        
        response["next_page_token"] = next_page_token
        return response
    except Exception:
        return JSONResponse(status_code=500, content={"message": "Failed to list vulnerabilities."})


@vulnerabilitiy_router.get("/get-vulnerabilities", dependencies=[Depends(verify_access_token), Depends(create_bucket_for_token)])
async def list_vulnerabilitiy(
    page_token: str = Query(default=""),
    limit: int = Query(default=100, ge=1, le=1000),
    filter_query: str = Query(default="")
    ):
    """Fetch vulnerabilities using pagination mechanism.

    429 status code if user reach max api calls limit. (100 api calls per hour). 

    Args:
        page_token (str, optional): Provide page token. Defaults to Query(default="").
        limit (int, optional): Limit number of vulnerabilities to fetch. Defaults to Query(default=100, ge=1, le=1000).

    Returns:
        dict: List of vulnerabilities and annotated information.
    """
    try:
        response = {"total": 0, "vulnerabilities": []}

        if not filter_query:
            return await list_vulnerabilities_by_page_token(page_token, limit)
        
        data = await VR_ACTIONS.fetch_vulnerabilities_by_filters(
            vulnerabilities_db_manager,
            values={"limit": limit},
            filter_query=VR_QUERIES.FILTER_VULNERABILITIES.format(filter_query)
        )
        response["vulnerabilities"] = data
        response["total"] = len(data)
        return response
    except Exception:
        return JSONResponse(status_code=500, content={"message": "Failed to list vulnerabilities."})

@vulnerabilitiy_router.get("/get-affected_devices", dependencies=[Depends(verify_access_token), Depends(create_bucket_for_token)])
async def list_affected_devices_for_cve_id(cve_id : str = Query(..., regex=r"^CVE-\d{4}-\d{1,10}$"), limit: int = Query(10, ge=1, le=100)):
    """List vulnerable devices by CVE ID.

    429 status code if user reach max api calls limit. (100 api calls per hour). 
    
    Args:
        cve_id (str): Specify cve id for affected devices.
        limit (int, optional): Provide limit for max number of affected devices to fetch. Defaults to 10.

    Returns:
        dict: API Response.
    """
    try:
        response = {"total": 0, "devices": []}
        data = await VR_ACTIONS.fetch_affected_devices_by_cve_id(
            devices_db_manager,
            values={"cve_id": cve_id, "limit": limit},
        )
        response["devices"] = data
        response["total"] = len(data)
        return response
    except Exception:
        return JSONResponse(status_code=500, content={"message": "Failed to list vulnerable devices of cve id - {0}.".format(cve_id)})
